<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë²Œì§‘ ìœ¡ê°í˜• êµ¬ì¡° ìµœì í™” ì‹œë®¬ë ˆì´ì…˜</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .tab-button {
            flex: 1;
            min-width: 200px;
            padding: 15px 25px;
            background: rgba(255,255,255,0.2);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .tab-button:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
        }

        .tab-button.active {
            background: white;
            color: #667eea;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.5s;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 20px;
        }

        .card h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.8rem;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        .card h3 {
            color: #764ba2;
            margin-top: 25px;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .grid-2 {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
            font-size: 1.1rem;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        input[type="range"] {
            flex: 1;
            height: 8px;
            border-radius: 5px;
            background: linear-gradient(to right, #667eea, #764ba2);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            border: none;
        }

        .value-display {
            min-width: 100px;
            text-align: right;
            font-weight: 700;
            color: #667eea;
            font-size: 1.2rem;
        }

        canvas {
            width: 100%;
            border-radius: 10px;
            background: #f8f9fa;
            display: block;
        }

        #canvas2d {
            height: 650px;
            margin: 30px 0;
        }

        #canvas3d {
            height: 500px;
        }

        #chartCanvas {
            height: 400px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }

        .stat-card.optimal {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            color: #333;
            border: 3px solid #ff6b6b;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .stat-card .label {
            font-size: 1rem;
            opacity: 0.9;
            margin-bottom: 8px;
        }

        .stat-card .value {
            font-size: 2rem;
            font-weight: 700;
        }

        .stat-card.optimal .label {
            opacity: 1;
            font-weight: 600;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 1.05rem;
        }

        .comparison-table th,
        .comparison-table td {
            padding: 18px;
            text-align: center;
            border-bottom: 1px solid #eee;
        }

        .comparison-table th {
            background: #667eea;
            color: white;
            font-weight: 600;
            font-size: 1.1rem;
        }

        .comparison-table tr:hover {
            background: #f8f9fa;
        }

        .comparison-table tr.optimal {
            background: #ffd700;
            font-weight: 700;
            font-size: 1.1rem;
        }

        .comparison-table tr.optimal td {
            border-top: 3px solid #ff6b6b;
            border-bottom: 3px solid #ff6b6b;
        }

        .info-box {
            background: #e8f4f8;
            border-left: 4px solid #667eea;
            padding: 18px 25px;
            margin: 20px 0;
            border-radius: 5px;
            font-size: 1.05rem;
            line-height: 1.6;
        }

        .info-box strong {
            color: #667eea;
        }

        .info-box.warning {
            background: #fff4e6;
            border-left-color: #ffd700;
        }

        .info-box.warning strong {
            color: #ff6b6b;
        }

        .result-highlight {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            padding: 30px;
            border-radius: 15px;
            margin: 30px 0;
            border: 3px solid #ff6b6b;
            text-align: center;
            box-shadow: 0 8px 20px rgba(0,0,0,0.15);
        }

        .result-highlight h3 {
            color: #333;
            margin: 0 0 15px 0;
            font-size: 1.8rem;
        }

        .result-highlight .big-value {
            font-size: 3.5rem;
            font-weight: 700;
            color: #667eea;
            margin: 15px 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .result-highlight p {
            font-size: 1.3rem;
            color: #333;
            margin: 10px 0;
        }

        .size-indicator {
            background: linear-gradient(135deg, #e8f4f8, #d4e9f7);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            border: 2px solid #667eea;
            text-align: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }

        .size-indicator .metric {
            display: inline-block;
            margin: 0 20px;
            font-size: 1.2rem;
            font-weight: 600;
        }

        .size-indicator .metric strong {
            color: #667eea;
            font-size: 1.4rem;
        }

        .size-indicator .metric .value {
            color: #ff6b6b;
            font-size: 1.5rem;
        }

        @media (max-width: 768px) {
            header h1 {
                font-size: 1.8rem;
            }

            .card {
                padding: 20px;
            }

            #canvas2d {
                height: 550px;
            }

            canvas {
                height: 350px !important;
            }

            .result-highlight .big-value {
                font-size: 2.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸ ë²Œì§‘ ìœ¡ê°í˜• êµ¬ì¡°ì˜ ê¸°í•˜í•™ì  ìµœì í™”</h1>
            <p>í™˜ê²½ ì¡°ê±´ì— ë”°ë¥¸ ìµœì  êµ¬ì¡° ìë™ ê³„ì‚° ì‹œë®¬ë ˆì´ì…˜</p>
        </header>

        <div class="tabs">
            <button class="tab-button active" onclick="openTab('tab1')">2D í‰ë©´ ìµœì í™”</button>
            <button class="tab-button" onclick="openTab('tab2')">3D ë¶€í”¼ ìµœì í™”</button>
            <button class="tab-button" onclick="openTab('tab3')">ê°ë„ ìµœì í™” ë¶„ì„</button>
        </div>

        <!-- Tab 1: 2D í‰ë©´ ìµœì í™” -->
        <div id="tab1" class="tab-content active">
            <div class="card">
                <h2>í‰ë©´ í…Œì…€ë ˆì´ì…˜ ìµœì í™”</h2>
                <div class="info-box">
                    <strong>ëª©ì :</strong> ì£¼ì–´ì§„ ë©´ì ì„ ì±„ìš°ëŠ” ë° í•„ìš”í•œ ì¬ë£Œ(ë‘˜ë ˆ)ë¥¼ ìµœì†Œí™”í•˜ëŠ” ì •ë‹¤ê°í˜• ì°¾ê¸°
                </div>
                
                <h3>í™˜ê²½ ë³€ìˆ˜ ì„¤ì •</h3>
                <div class="control-group">
                    <label>í•„ìš”í•œ ì´ ë©´ì  $A_{\text{total}}$</label>
                    <div class="slider-container">
                        <input type="range" id="totalArea" min="100" max="1000" value="500" step="50">
                        <span class="value-display"><span id="totalArea-value">500</span> cmÂ²</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>ì…€ ê°œìˆ˜ $n$ (ë²Œì§‘ ì¹¸ ìˆ˜)</label>
                    <div class="slider-container">
                        <input type="range" id="cellCount" min="10" max="100" value="50" step="10">
                        <span class="value-display"><span id="cellCount-value">50</span> ê°œ</span>
                    </div>
                </div>

                <div class="size-indicator">
                    <div class="metric">
                        <strong>ì…€ë‹¹ ë©´ì :</strong> <span class="value" id="cellArea-display">10.00</span> cmÂ²
                    </div>
                    <div class="metric">
                        <strong>ì •ìœ¡ê°í˜• í•œ ë³€:</strong> <span class="value" id="hexSide-display">2.41</span> cm
                    </div>
                </div>

                <canvas id="canvas2d"></canvas>

                <div class="result-highlight">
                    <h3>ğŸ† ìµœì  ë„í˜•</h3>
                    <div class="big-value" id="optimal2d">ì •ìœ¡ê°í˜•</div>
                    <p>ì¬ë£Œ ì ˆì•½ë¥ : <strong id="saving2d">-</strong></p>
                </div>

                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>ë„í˜•</th>
                            <th>ì…€ë‹¹ ë©´ì  $A$</th>
                            <th>í•œ ë³€ì˜ ê¸¸ì´ $s$</th>
                            <th>ì…€ë‹¹ ë‘˜ë ˆ $L$</th>
                            <th>ì´ ë‘˜ë ˆ ê¸¸ì´</th>
                            <th>íš¨ìœ¨ì„± ì§€ìˆ˜</th>
                        </tr>
                    </thead>
                    <tbody id="comparison-tbody">
                    </tbody>
                </table>

                <div class="info-box warning">
                    <strong>ìˆ˜í•™ì  ì¦ëª…:</strong> ë“±ì£¼ ë¶€ë“±ì‹ì— ì˜í•´ ë™ì¼ ë©´ì  ëŒ€ë¹„ ë‘˜ë ˆê°€ ìµœì†Œì¸ ë„í˜•ì€ ì›ì´ì§€ë§Œ, 
                    í‰ë©´ì„ ë¹ˆí‹ˆì—†ì´ ì±„ìš¸ ìˆ˜ ìˆëŠ” ì •ë‹¤ê°í˜•ì€ $n=3, 4, 6$ë§Œ ê°€ëŠ¥í•˜ë©°, ì´ ì¤‘ ì •ìœ¡ê°í˜•ì´ ì›ì— ê°€ì¥ ê°€ê¹Œìš´ íš¨ìœ¨ì„ ê°€ì§
                </div>
            </div>
        </div>

        <!-- Tab 2: 3D ë¶€í”¼ ìµœì í™” -->
        <div id="tab2" class="tab-content">
            <div class="card">
                <h2>3D ë²Œì§‘ ì…€ ë¶€í”¼-í‘œë©´ì  ìµœì í™”</h2>
                
                <div class="info-box">
                    <strong>ëª©ì :</strong> ì£¼ì–´ì§„ ë¶€í”¼ë¥¼ ì €ì¥í•˜ê¸° ìœ„í•´ í•„ìš”í•œ í‘œë©´ì (ì¬ë£Œ)ì„ ìµœì†Œí™”í•˜ëŠ” ë°”ë‹¥ êµ¬ì¡° ì°¾ê¸°
                </div>

                <h3>í™˜ê²½ ë³€ìˆ˜ ì„¤ì •</h3>
                <div class="grid-2">
                    <div class="control-group">
                        <label>í•„ìš”í•œ ë¶€í”¼ $V$</label>
                        <div class="slider-container">
                            <input type="range" id="requiredVolume" min="10" max="100" value="50" step="5">
                            <span class="value-display"><span id="requiredVolume-value">50</span> cmÂ³</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <label>ìœ¡ê°í˜• í•œ ë³€ $s$</label>
                        <div class="slider-container">
                            <input type="range" id="hexSide" min="1" max="3" value="2" step="0.1">
                            <span class="value-display"><span id="hexSide-value">2.0</span> cm</span>
                        </div>
                    </div>
                </div>

                <canvas id="canvas3d"></canvas>

                <div class="result-highlight">
                    <h3>ğŸ¯ ìµœì  ë°”ë‹¥ ê°ë„</h3>
                    <div class="big-value">
                        Î¸ = <span id="optimalTheta3d">35.26</span>Â°
                    </div>
                    <p>ë§ˆë¦„ëª¨ ë‘”ê°: <strong id="optimalRhombus">109.47Â°</strong></p>
                    <p>ì¬ë£Œ ì ˆì•½ë¥ : <strong id="saving3d">-</strong></p>
                </div>

                <h3>ë°”ë‹¥ êµ¬ì¡° ë¹„êµ</h3>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="label">í‰í‰í•œ ë°”ë‹¥</div>
                        <div class="value"><span id="flatSurface">-</span> cmÂ²</div>
                    </div>
                    <div class="stat-card optimal">
                        <div class="label">â­ ë§ˆë¦„ëª¨ ë°”ë‹¥ (ìµœì )</div>
                        <div class="value"><span id="rhombusSurface">-</span> cmÂ²</div>
                    </div>
                    <div class="stat-card">
                        <div class="label">ì ˆì•½ëŸ‰</div>
                        <div class="value"><span id="savedMaterial">-</span> cmÂ²</div>
                    </div>
                </div>

                <div class="info-box warning">
                    <strong>ì´ë¡ ê°’:</strong> $\cos\theta = \frac{1}{\sqrt{3}}$ì¼ ë•Œ í‘œë©´ì  ìµœì†Œ<br>
                    $\theta = \arccos\left(\frac{1}{\sqrt{3}}\right) \approx 35.26Â°$<br>
                    ë§ˆë¦„ëª¨ ë‘”ê° $\alpha = 2\arccos\left(\frac{1}{\sqrt{3}}\right) \approx 109.47Â°$
                </div>
            </div>
        </div>

        <!-- Tab 3: ê°ë„ ìµœì í™” ë¶„ì„ -->
        <div id="tab3" class="tab-content">
            <div class="card">
                <h2>ë°”ë‹¥ ê°ë„ì— ë”°ë¥¸ í‘œë©´ì  ë³€í™” ë¶„ì„</h2>
                
                <div class="info-box">
                    ì „ì²´ í‘œë©´ì  $S(\theta)$ë¥¼ $\theta$ì— ëŒ€í•´ ë¯¸ë¶„í•˜ì—¬ ìµœì†Ÿê°’ì„ ì°¾ëŠ” ê³¼ì •ì„ ì‹œê°í™”
                </div>

                <h3>í™˜ê²½ ë³€ìˆ˜</h3>
                <div class="grid-2">
                    <div class="control-group">
                        <label>ìœ¡ê°í˜• í•œ ë³€ $s$</label>
                        <div class="slider-container">
                            <input type="range" id="sideChart" min="1" max="3" value="2" step="0.1">
                            <span class="value-display"><span id="sideChart-value">2.0</span> cm</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <label>ê¸°ë‘¥ ë†’ì´ $h$</label>
                        <div class="slider-container">
                            <input type="range" id="heightChart" min="2" max="8" value="5" step="0.5">
                            <span class="value-display"><span id="heightChart-value">5.0</span> cm</span>
                        </div>
                    </div>
                </div>

                <canvas id="chartCanvas"></canvas>

                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="label">ì´ë¡  ìµœì ê° $\theta$</div>
                        <div class="value">35.26Â°</div>
                    </div>
                    <div class="stat-card optimal">
                        <div class="label">â­ ìˆ˜ì¹˜ ìµœì ê°</div>
                        <div class="value"><span id="numericalOptimal">-</span>Â°</div>
                    </div>
                    <div class="stat-card">
                        <div class="label">ìµœì†Œ í‘œë©´ì </div>
                        <div class="value"><span id="minSurface">-</span> cmÂ²</div>
                    </div>
                    <div class="stat-card">
                        <div class="label">ì˜¤ì°¨ìœ¨</div>
                        <div class="value"><span id="errorRate">-</span>%</div>
                    </div>
                </div>

                <div class="info-box">
                    <strong>í‘œë©´ì  í•¨ìˆ˜ ìœ ë„:</strong><br>
                    ë°”ë‹¥ë©´ 3ê°œ ë§ˆë¦„ëª¨ ë„“ì´: $S_{\text{bottom}} = \frac{3\sqrt{3}s^2}{2\cos\theta}$<br>
                    ì˜†ë©´ ë„“ì´: $S_{\text{side}} = 6sh - 3s^2\tan\theta$<br>
                    ì „ì²´: $S(\theta) = \frac{3\sqrt{3}s^2}{2\cos\theta} + 6sh - 3s^2\tan\theta$<br>
                    ìµœì í™”: $\frac{dS}{d\theta} = 0$
                </div>

                <div class="info-box warning">
                    <strong>Fejes TÃ³thì˜ ë°œê²¬:</strong> 1964ë…„ ë…¼ë¬¸ì—ì„œ ê¸°ì¡´ ë²Œì§‘ êµ¬ì¡°ë³´ë‹¤ ì•½ 0.35% ë” íš¨ìœ¨ì ì¸ êµ¬ì¡°ë¥¼ ìˆ˜í•™ì ìœ¼ë¡œ ì¦ëª…í–ˆìœ¼ë‚˜, 
                    ìì—°ì€ ê±´ì¶• ë³µì¡ë„ì™€ íš¨ìœ¨ì„± ì‚¬ì´ì˜ ê· í˜•ì ì„ ì„ íƒí•¨
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ===== ì „ì—­ ë³€ìˆ˜ =====
        let scene, camera, renderer, honeycombCell;
        const OPTIMAL_THETA = Math.acos(1/Math.sqrt(3)) * 180 / Math.PI;
        const SQRT3 = Math.sqrt(3);

        // ===== Tab ì „í™˜ =====
        function openTab(tabId) {
            const contents = document.querySelectorAll('.tab-content');
            const buttons = document.querySelectorAll('.tab-button');
            
            contents.forEach(content => content.classList.remove('active'));
            buttons.forEach(button => button.classList.remove('active'));
            
            document.getElementById(tabId).classList.add('active');
            event.target.classList.add('active');

            if (tabId === 'tab2' && !renderer) {
                init3D();
            }
            if (tabId === 'tab3') {
                drawOptimizationChart();
            }
        }

        // ===== Tab 1: 2D í‰ë©´ ìµœì í™” =====
        function calculate2DOptimal() {
            const totalArea = parseFloat(document.getElementById('totalArea').value);
            const cellCount = parseFloat(document.getElementById('cellCount').value);
            const cellArea = totalArea / cellCount;
            
            const shapes = [
                { 
                    name: 'ì •ì‚¼ê°í˜•', 
                    sides: 3,
                    color: '#FF6B6B',
                    sideLength: Math.sqrt(4 * cellArea / SQRT3),
                    efficiencyFactor: 4.559
                },
                { 
                    name: 'ì •ì‚¬ê°í˜•', 
                    sides: 4,
                    color: '#4ECDC4',
                    sideLength: Math.sqrt(cellArea),
                    efficiencyFactor: 4.000
                },
                { 
                    name: 'ì •ìœ¡ê°í˜•', 
                    sides: 6,
                    color: '#FFD93D',
                    sideLength: Math.sqrt(2 * cellArea / (3 * SQRT3)),
                    efficiencyFactor: 3.722
                }
            ];
            
            shapes.forEach(shape => {
                shape.perimeter = shape.sides * shape.sideLength;
                shape.totalPerimeter = shape.perimeter * cellCount;
                shape.efficiency = shape.perimeter / Math.sqrt(cellArea);
            });
            
            const optimal = shapes.reduce((min, s) => s.totalPerimeter < min.totalPerimeter ? s : min);
            const worst = shapes.reduce((max, s) => s.totalPerimeter > max.totalPerimeter ? s : max);
            const saving = ((worst.totalPerimeter - optimal.totalPerimeter) / worst.totalPerimeter * 100).toFixed(2);
            
            document.getElementById('optimal2d').textContent = optimal.name;
            document.getElementById('saving2d').textContent = `ì •ì‚¼ê°í˜• ëŒ€ë¹„ ${saving}% ì ˆì•½`;
            
            document.getElementById('cellArea-display').textContent = cellArea.toFixed(2);
            document.getElementById('hexSide-display').textContent = shapes[2].sideLength.toFixed(2);
            
            return { shapes, cellArea, optimal };
        }

        function draw2DTessellation() {
            const canvas = document.getElementById('canvas2d');
            const ctx = canvas.getContext('2d');
            
            canvas.width = canvas.offsetWidth;
            canvas.height = 650;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const { shapes, cellArea } = calculate2DOptimal();
            
            const padding = 50;
            const availableWidth = canvas.width - 2 * padding;
            const spacing = availableWidth / 3;
            
            // cellArea ê¸°ë°˜ìœ¼ë¡œ í¬ê¸° ìŠ¤ì¼€ì¼ ê²°ì • (ë©´ì ì— ë¹„ë¡€í•˜ë„ë¡)
            // cellArea ë²”ìœ„: 1(min) ~ 100(max)
            // ë°˜ì§€ë¦„ ë²”ìœ„: 30px ~ 140px ì •ë„ë¡œ ë§¤í•‘
            const minArea = 1;
            const maxArea = 100;
            const minRadius = 30;
            const maxRadius = 140;
            
            // cellAreaì˜ ì œê³±ê·¼ì— ë¹„ë¡€í•˜ì—¬ ë°˜ì§€ë¦„ ê³„ì‚° (ë©´ì  = Ï€*r^2 ì´ë¯€ë¡œ)
            const baseRadius = minRadius + (Math.sqrt(cellArea) - Math.sqrt(minArea)) / 
                               (Math.sqrt(maxArea) - Math.sqrt(minArea)) * (maxRadius - minRadius);
            
            shapes.forEach((shape, idx) => {
                const x = padding + spacing * idx + spacing / 2;
                const y = canvas.height / 2;
                
                const isOptimal = shape.name === 'ì •ìœ¡ê°í˜•';
                
                ctx.save();
                ctx.translate(x, y - 100);
                ctx.beginPath();
                
                // ê° ë„í˜•ë³„ë¡œ ê¸°ì¤€ ë°˜ì§€ë¦„ ì¡°ì •
                let radius;
                if (shape.sides === 3) {
                    radius = baseRadius * 1.1; // ì‚¼ê°í˜• ì•½ê°„ í¬ê²Œ
                } else if (shape.sides === 4) {
                    radius = baseRadius * 1.0;
                } else {
                    radius = baseRadius * 1.05; // ìœ¡ê°í˜•
                }
                
                // ë„í˜• ê·¸ë¦¬ê¸°
                for (let i = 0; i <= shape.sides; i++) {
                    const angle = (i / shape.sides) * Math.PI * 2 - Math.PI / 2;
                    const px = Math.cos(angle) * radius;
                    const py = Math.sin(angle) * radius;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                
                ctx.fillStyle = shape.color + (isOptimal ? '70' : '40');
                ctx.fill();
                ctx.strokeStyle = shape.color;
                ctx.lineWidth = isOptimal ? 5 : 3;
                ctx.stroke();
                
                // í•œ ë³€ì˜ ê¸¸ì´ í‘œì‹œ
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                
                if (shape.sides === 3) {
                    const angle1 = -Math.PI / 2 + (2 * Math.PI / 3);
                    const angle2 = -Math.PI / 2 + (4 * Math.PI / 3);
                    const p1x = Math.cos(angle1) * radius;
                    const p1y = Math.sin(angle1) * radius;
                    const p2x = Math.cos(angle2) * radius;
                    const p2y = Math.sin(angle2) * radius;
                    
                    ctx.beginPath();
                    ctx.moveTo(p1x, p1y);
                    ctx.lineTo(p2x, p2y);
                    ctx.stroke();
                    
                    ctx.setLineDash([]);
                    ctx.strokeStyle = '#ff6b6b';
                    ctx.lineWidth = 3;
                    const offset = 25;
                    ctx.beginPath();
                    ctx.moveTo(p1x, p1y + offset);
                    ctx.lineTo(p2x, p2y + offset);
                    ctx.stroke();
                    
                    drawArrow(ctx, p1x, p1y + offset, p1x + 10, p1y + offset);
                    drawArrow(ctx, p2x, p2y + offset, p2x - 10, p2y + offset);
                    
                    ctx.fillStyle = '#ff6b6b';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${shape.sideLength.toFixed(2)} cm`, 0, radius * 0.8 + offset);
                } else if (shape.sides === 4) {
                    const r2 = radius / Math.sqrt(2);
                    
                    ctx.beginPath();
                    ctx.moveTo(-r2, r2);
                    ctx.lineTo(r2, r2);
                    ctx.stroke();
                    
                    ctx.setLineDash([]);
                    ctx.strokeStyle = '#4ECDC4';
                    ctx.lineWidth = 3;
                    const offset = 25;
                    ctx.beginPath();
                    ctx.moveTo(-r2, r2 + offset);
                    ctx.lineTo(r2, r2 + offset);
                    ctx.stroke();
                    
                    drawArrow(ctx, -r2, r2 + offset, -r2 + 10, r2 + offset);
                    drawArrow(ctx, r2, r2 + offset, r2 - 10, r2 + offset);
                    
                    ctx.fillStyle = '#4ECDC4';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${shape.sideLength.toFixed(2)} cm`, 0, r2 + offset + 20);
                } else {
                    const angle1 = Math.PI / 6;
                    const angle2 = Math.PI / 2;
                    const p1x = Math.cos(angle1) * radius;
                    const p1y = Math.sin(angle1) * radius;
                    const p2x = Math.cos(angle2) * radius;
                    const p2y = Math.sin(angle2) * radius;
                    
                    ctx.beginPath();
                    ctx.moveTo(p1x, p1y);
                    ctx.lineTo(p2x, p2y);
                    ctx.stroke();
                    
                    ctx.setLineDash([]);
                    ctx.strokeStyle = '#FFD93D';
                    ctx.lineWidth = 3;
                    const offset = 15;
                    const dx = p2x - p1x;
                    const dy = p2y - p1y;
                    const len = Math.sqrt(dx*dx + dy*dy);
                    const nx = -dy / len * offset;
                    const ny = dx / len * offset;
                    
                    ctx.beginPath();
                    ctx.moveTo(p1x + nx, p1y + ny);
                    ctx.lineTo(p2x + nx, p2y + ny);
                    ctx.stroke();
                    
                    drawArrow(ctx, p1x + nx, p1y + ny, p1x + nx + dy/len*10, p1y + ny - dx/len*10);
                    drawArrow(ctx, p2x + nx, p2y + ny, p2x + nx - dy/len*10, p2y + ny + dx/len*10);
                    
                    ctx.fillStyle = '#FFD93D';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${shape.sideLength.toFixed(2)} cm`, (p1x + p2x)/2 + nx + 15, (p1y + p2y)/2 + ny);
                }
                
                ctx.setLineDash([]);
                
                // ìµœì  ë„í˜• ê°•ì¡°
                if (isOptimal) {
                    ctx.strokeStyle = '#FF6B6B';
                    ctx.lineWidth = 4;
                    ctx.setLineDash([8, 8]);
                    ctx.beginPath();
                    ctx.arc(0, 0, radius + 25, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 50px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('â­', 0, -radius - 50);
                }
                
                ctx.restore();
                
                // ì •ë³´ í‘œì‹œ
                ctx.fillStyle = '#333';
                ctx.font = isOptimal ? 'bold 26px Arial' : 'bold 22px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(shape.name, x, y + 160);
                
                if (isOptimal) {
                    ctx.fillStyle = '#FF6B6B';
                    ctx.font = 'bold 20px Arial';
                    ctx.fillText('âœ“ ìµœì  ë„í˜•', x, y + 190);
                }
                
                ctx.fillStyle = '#555';
                ctx.font = '16px Arial';
                const yOffset = isOptimal ? 215 : 190;
                ctx.fillText(`ë©´ì : ${cellArea.toFixed(2)} cmÂ²`, x, y + yOffset);
                ctx.fillText(`ë‘˜ë ˆ: ${shape.perimeter.toFixed(2)} cm`, x, y + yOffset + 24);
            });
            
            // ì œëª©
            ctx.fillStyle = '#333';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ì •ë‹¤ê°í˜• í…Œì…€ë ˆì´ì…˜ íš¨ìœ¨ ë¹„êµ', canvas.width / 2, 35);
            ctx.font = '16px Arial';
            ctx.fillStyle = '#666';
            ctx.fillText('(ë„í˜• í¬ê¸°ëŠ” ì…€ë‹¹ ë©´ì ì— ë¹„ë¡€)', canvas.width / 2, 60);
        }

        function drawArrow(ctx, x1, y1, x2, y2) {
            const headlen = 8;
            const dx = x2 - x1;
            const dy = y2 - y1;
            const angle = Math.atan2(dy, dx);
            
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - headlen * Math.cos(angle - Math.PI / 6), y2 - headlen * Math.sin(angle - Math.PI / 6));
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - headlen * Math.cos(angle + Math.PI / 6), y2 - headlen * Math.sin(angle + Math.PI / 6));
            ctx.stroke();
        }

        function updateComparisonTable() {
            const { shapes, cellArea } = calculate2DOptimal();
            const tbody = document.getElementById('comparison-tbody');
            
            tbody.innerHTML = shapes.map(shape => {
                const isOptimal = shape.name === 'ì •ìœ¡ê°í˜•';
                return `
                    <tr ${isOptimal ? 'class="optimal"' : ''}>
                        <td><strong>${shape.name}</strong> ${isOptimal ? 'â­' : ''}</td>
                        <td>${cellArea.toFixed(2)}</td>
                        <td>${shape.sideLength.toFixed(3)}</td>
                        <td>${shape.perimeter.toFixed(3)}</td>
                        <td><strong>${shape.totalPerimeter.toFixed(2)}</strong></td>
                        <td>${shape.efficiency.toFixed(3)}</td>
                    </tr>
                `;
            }).join('');
        }

        // ===== Tab 2: 3D ë¶€í”¼ ìµœì í™” =====
        function init3D() {
            const canvas = document.getElementById('canvas3d');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf8f9fa);
            
            camera = new THREE.PerspectiveCamera(45, canvas.offsetWidth / 500, 0.1, 1000);
            camera.position.set(10, 10, 10);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(canvas.offsetWidth, 500);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 10);
            scene.add(directionalLight);
            
            const gridHelper = new THREE.GridHelper(20, 20, 0xcccccc, 0xeeeeee);
            scene.add(gridHelper);
            
            calculate3DOptimal();
            animate3D();
        }

        function calculate3DOptimal() {
            const requiredVolume = parseFloat(document.getElementById('requiredVolume').value);
            const s = parseFloat(document.getElementById('hexSide').value);
            
            const hexBaseArea = (3 * SQRT3 / 2) * s * s;
            const requiredHeight = requiredVolume / hexBaseArea;
            
            const optimalTheta = OPTIMAL_THETA;
            const optimalThetaRad = optimalTheta * Math.PI / 180;
            
            const flatBottomArea = hexBaseArea;
            const flatSideArea = 6 * s * requiredHeight;
            const flatTotalArea = flatBottomArea + flatSideArea;
            
            const rhombusBottomArea = (3 * SQRT3 * s * s / 2) / Math.cos(optimalThetaRad);
            const rhombusDepth = s * Math.tan(optimalThetaRad) / SQRT3;
            const rhombusSideArea = 6 * s * (requiredHeight - rhombusDepth);
            const rhombusTotalArea = rhombusBottomArea + rhombusSideArea;
            
            const saved = flatTotalArea - rhombusTotalArea;
            const savingPercent = (saved / flatTotalArea * 100).toFixed(2);
            
            document.getElementById('flatSurface').textContent = flatTotalArea.toFixed(2);
            document.getElementById('rhombusSurface').textContent = rhombusTotalArea.toFixed(2);
            document.getElementById('savedMaterial').textContent = saved.toFixed(2);
            document.getElementById('optimalTheta3d').textContent = optimalTheta.toFixed(2);
            document.getElementById('optimalRhombus').textContent = (2 * optimalTheta).toFixed(2) + 'Â°';
            document.getElementById('saving3d').textContent = `í‰í‰í•œ ë°”ë‹¥ ëŒ€ë¹„ ${savingPercent}% ì ˆì•½`;
            
            createHoneycombCell(s, requiredHeight, optimalThetaRad);
        }

        function createHoneycombCell(s, h, theta) {
            if (honeycombCell) scene.remove(honeycombCell);
            
            honeycombCell = new THREE.Group();
            
            const hexPoints = [];
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                hexPoints.push(new THREE.Vector2(Math.cos(angle) * s, Math.sin(angle) * s));
            }
            
            const hexShape = new THREE.Shape(hexPoints);
            const extrudeSettings = { depth: h, bevelEnabled: false };
            const hexGeometry = new THREE.ExtrudeGeometry(hexShape, extrudeSettings);
            const hexMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFFD93D, 
                transparent: true, 
                opacity: 0.5,
                side: THREE.DoubleSide
            });
            const hexMesh = new THREE.Mesh(hexGeometry, hexMaterial);
            honeycombCell.add(hexMesh);
            
            const rhombusDepth = s * Math.tan(theta) / SQRT3;
            
            for (let i = 0; i < 3; i++) {
                const angle = (i / 3) * Math.PI * 2;
                const nextAngle = ((i + 1) / 3) * Math.PI * 2;
                
                const p1 = new THREE.Vector3(0, 0, -rhombusDepth);
                const p2 = new THREE.Vector3(Math.cos(angle) * s, Math.sin(angle) * s, 0);
                const p3 = new THREE.Vector3(
                    (Math.cos(angle) + Math.cos(nextAngle)) * s / SQRT3,
                    (Math.sin(angle) + Math.sin(nextAngle)) * s / SQRT3,
                    0
                );
                const p4 = new THREE.Vector3(Math.cos(nextAngle) * s, Math.sin(nextAngle) * s, 0);
                
                const rhombusGeometry = new THREE.BufferGeometry();
                const vertices = new Float32Array([
                    p1.x, p1.y, p1.z,
                    p2.x, p2.y, p2.z,
                    p3.x, p3.y, p3.z,
                    
                    p1.x, p1.y, p1.z,
                    p3.x, p3.y, p3.z,
                    p4.x, p4.y, p4.z
                ]);
                rhombusGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                rhombusGeometry.computeVertexNormals();
                
                const rhombusMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xFF6B6B, 
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.8
                });
                const rhombusMesh = new THREE.Mesh(rhombusGeometry, rhombusMaterial);
                honeycombCell.add(rhombusMesh);
                
                const edgesGeometry = new THREE.EdgesGeometry(rhombusGeometry);
                const edgesMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
                const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
                honeycombCell.add(edges);
            }
            
            const hexEdges = new THREE.EdgesGeometry(hexGeometry);
            const hexEdgesMaterial = new THREE.LineBasicMaterial({ color: 0x333333 });
            const hexEdgesMesh = new THREE.LineSegments(hexEdges, hexEdgesMaterial);
            honeycombCell.add(hexEdgesMesh);
            
            scene.add(honeycombCell);
        }

        let rotation = 0;
        function animate3D() {
            requestAnimationFrame(animate3D);
            
            if (honeycombCell) {
                rotation += 0.005;
                honeycombCell.rotation.y = rotation;
            }
            
            renderer.render(scene, camera);
        }

        // ===== Tab 3: ê°ë„ ìµœì í™” ì°¨íŠ¸ =====
        function drawOptimizationChart() {
            const canvas = document.getElementById('chartCanvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = canvas.offsetWidth;
            canvas.height = 400;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const s = parseFloat(document.getElementById('sideChart').value);
            const h = parseFloat(document.getElementById('heightChart').value);
            
            const padding = 60;
            const graphWidth = canvas.width - 2 * padding;
            const graphHeight = canvas.height - 2 * padding;
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, canvas.height - padding);
            ctx.lineTo(canvas.width - padding, canvas.height - padding);
            ctx.stroke();
            
            const data = [];
            let minArea = Infinity;
            let optimalTheta = 0;
            let maxArea = -Infinity;
            
            for (let deg = 0.1; deg <= 60; deg += 0.2) {
                const theta = deg * Math.PI / 180;
                const bottomArea = (3 * SQRT3 * s * s / 2) / Math.cos(theta);
                const sideArea = 6 * s * h - 3 * s * s * Math.tan(theta);
                const totalArea = bottomArea + sideArea;
                
                data.push({ theta: deg, area: totalArea });
                
                if (totalArea < minArea) {
                    minArea = totalArea;
                    optimalTheta = deg;
                }
                if (totalArea > maxArea) {
                    maxArea = totalArea;
                }
            }
            
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            data.forEach((point, idx) => {
                const x = padding + (point.theta / 60) * graphWidth;
                const y = canvas.height - padding - ((point.area - minArea) / (maxArea - minArea)) * graphHeight;
                
                if (idx === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            
            ctx.stroke();
            
            const theoreticalX = padding + (OPTIMAL_THETA / 60) * graphWidth;
            const theoreticalPoint = data.find(d => Math.abs(d.theta - OPTIMAL_THETA) < 0.5);
            const theoreticalY = canvas.height - padding - ((theoreticalPoint.area - minArea) / (maxArea - minArea)) * graphHeight;
            
            ctx.fillStyle = '#FF6B6B';
            ctx.beginPath();
            ctx.arc(theoreticalX, theoreticalY, 10, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = '#FF6B6B';
            ctx.setLineDash([5, 5]);
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(theoreticalX, canvas.height - padding);
            ctx.lineTo(theoreticalX, theoreticalY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ë°”ë‹¥ ê°ë„ Î¸ (ë„)', canvas.width / 2, canvas.height - 20);
            
            ctx.save();
            ctx.translate(20, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('ì „ì²´ í‘œë©´ì  S(Î¸)', 0, 0);
            ctx.restore();
            
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            for (let i = 0; i <= 6; i++) {
                const x = padding + (i / 6) * graphWidth;
                const label = (i * 10).toString();
                ctx.fillText(label, x, canvas.height - padding + 20);
                
                ctx.strokeStyle = '#eee';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, canvas.height - padding);
                ctx.stroke();
            }
            
            ctx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const y = canvas.height - padding - (i / 5) * graphHeight;
                const value = minArea + (maxArea - minArea) * (i / 5);
                ctx.fillText(value.toFixed(1), padding - 10, y + 5);
                
                ctx.strokeStyle = '#eee';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(canvas.width - padding, y);
                ctx.stroke();
            }
            
            ctx.fillStyle = '#FF6B6B';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`ìµœì ê°: ${OPTIMAL_THETA.toFixed(2)}Â°`, theoreticalX, theoreticalY - 20);
            
            document.getElementById('numericalOptimal').textContent = optimalTheta.toFixed(2);
            document.getElementById('minSurface').textContent = minArea.toFixed(3);
            
            const errorRate = Math.abs(optimalTheta - OPTIMAL_THETA) / OPTIMAL_THETA * 100;
            document.getElementById('errorRate').textContent = errorRate.toFixed(3);
            
            if (window.MathJax) {
                MathJax.typesetPromise();
            }
        }

        // ===== ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ =====
        document.getElementById('totalArea').addEventListener('input', function(e) {
            document.getElementById('totalArea-value').textContent = e.target.value;
            draw2DTessellation();
            updateComparisonTable();
        });

        document.getElementById('cellCount').addEventListener('input', function(e) {
            document.getElementById('cellCount-value').textContent = e.target.value;
            draw2DTessellation();
            updateComparisonTable();
        });

        document.getElementById('requiredVolume').addEventListener('input', function(e) {
            document.getElementById('requiredVolume-value').textContent = e.target.value;
            if (renderer) calculate3DOptimal();
        });

        document.getElementById('hexSide').addEventListener('input', function(e) {
            document.getElementById('hexSide-value').textContent = parseFloat(e.target.value).toFixed(1);
            if (renderer) calculate3DOptimal();
        });

        document.getElementById('sideChart').addEventListener('input', function(e) {
            document.getElementById('sideChart-value').textContent = parseFloat(e.target.value).toFixed(1);
            drawOptimizationChart();
        });

        document.getElementById('heightChart').addEventListener('input', function(e) {
            document.getElementById('heightChart-value').textContent = parseFloat(e.target.value).toFixed(1);
            drawOptimizationChart();
        });

        window.addEventListener('load', function() {
            draw2DTessellation();
            updateComparisonTable();
            
            setTimeout(() => {
                if (window.MathJax) {
                    MathJax.typesetPromise();
                }
            }, 1000);
        });

        window.addEventListener('resize', function() {
            draw2DTessellation();
            if (renderer) {
                const canvas = document.getElementById('canvas3d');
                camera.aspect = canvas.offsetWidth / 500;
                camera.updateProjectionMatrix();
                renderer.setSize(canvas.offsetWidth, 500);
            }
        });
    </script>
</body>
</html>
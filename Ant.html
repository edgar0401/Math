<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì‚¬ë§‰ê°œë¯¸ ê²½ë¡œ ì ë¶„ ì‹œë®¬ë ˆì´ì…˜ (ì •í™•í•œ êµ¬í˜„)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 900px;
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 24px;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 20px;
            font-size: 14px;
        }
        
        canvas {
            border: 3px solid #ddd;
            border-radius: 10px;
            display: block;
            margin: 0 auto;
            background: linear-gradient(to bottom, #f4e4c1 0%, #e8d4a8 100%);
            cursor: crosshair;
        }
        
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        button {
            padding: 12px 24px;
            font-size: 14px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .btn-primary {
            background: #4CAF50;
            color: white;
        }
        
        .btn-primary:hover {
            background: #45a049;
        }
        
        .btn-secondary {
            background: #2196F3;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #0b7dda;
        }
        
        .btn-danger {
            background: #f44336;
            color: white;
        }
        
        .btn-danger:hover {
            background: #da190b;
        }
        
        .info {
            margin-top: 20px;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 8px;
            font-size: 13px;
            line-height: 1.6;
        }
        
        .status {
            text-align: center;
            margin-top: 15px;
            font-size: 16px;
            font-weight: bold;
            color: #333;
            min-height: 24px;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }
        
        .legend-color {
            width: 30px;
            height: 15px;
            border-radius: 3px;
        }
        
        .mode-indicator {
            text-align: center;
            margin-top: 10px;
            color: #666;
            font-size: 14px;
        }
        
        .vector-info {
            margin-top: 15px;
            padding: 12px;
            background: #e3f2fd;
            border-radius: 8px;
            font-size: 12px;
            line-height: 1.8;
            font-family: 'Courier New', monospace;
        }
        
        .error-indicator {
            color: #f44336;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸœ ì‚¬ë§‰ê°œë¯¸ ê²½ë¡œ ì ë¶„ ì‹œë®¬ë ˆì´ì…˜</h1>
        <p class="subtitle">Cataglyphis fortis - ë²¡í„° í•©ì‚° & í•­ë²• ì˜¤ë¥˜ ê¸°ë°˜</p>
        
        <canvas id="canvas" width="800" height="600"></canvas>
        
        <div class="mode-indicator" id="modeIndicator">
            ğŸ“ ë¨¼ì € ì¶œë°œì (ë‘¥ì§€)ì„ í´ë¦­í•˜ì„¸ìš”
        </div>
        
        <div class="controls">
            <button class="btn-primary" onclick="startSimulation()">â–¶ ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘</button>
            <button class="btn-secondary" onclick="resetSimulation()">ğŸ”„ ë¦¬ì…‹</button>
            <button class="btn-danger" onclick="clearCanvas()">ğŸ—‘ï¸ ì „ì²´ ì§€ìš°ê¸°</button>
        </div>
        
        <div class="status" id="status"></div>
        
        <div class="vector-info" id="vectorInfo"></div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #8B4513; border: 2px solid #000;"></div>
                <span>ë‘¥ì§€ (ì¶œë°œì )</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #4CAF50;"></div>
                <span>ë¨¹ì´</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #2196F3;"></div>
                <span>íƒìƒ‰ ê²½ë¡œ</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FF5722;"></div>
                <span>ê·€í™˜ ê²½ë¡œ (ë²¡í„°í•© ê¸°ë°˜)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #9C27B0; opacity: 0.3;"></div>
                <span>ê³„ì‚°ëœ ê·€ì†Œ ë²¡í„°</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FF9800;"></div>
                <span>ë„ì°© ì§€ì </span>
            </div>
        </div>
        
        <div class="info">
            <strong>ğŸ“š ì‚¬ë§‰ê°œë¯¸ ê²½ë¡œ ì ë¶„ì˜ ì‹¤ì œ ì›ë¦¬:</strong><br>
            â€¢ <strong>ë²¡í„° ëˆ„ì :</strong> ê° ì´ë™ ìŠ¤í…ì„ ë²¡í„°ë¡œ ë³€í™˜í•˜ì—¬ í•©ì‚°<br>
            â€¢ <strong>ì¸¡ì • ì˜¤ë¥˜:</strong> ê±°ë¦¬ ì¸¡ì • ì˜¤ë¥˜(~5%), ë°©í–¥ ì¸¡ì • ì˜¤ë¥˜(~3-5ë„) í¬í•¨<br>
            â€¢ <strong>ê·€ì†Œ ë²¡í„°:</strong> ëˆ„ì ëœ ë²¡í„°ì˜ ì—­ë°©í–¥ì´ ì§‘ìœ¼ë¡œ ê°€ëŠ” ë°©í–¥<br>
            â€¢ <strong>ì¤‘ìš”:</strong> ê°œë¯¸ëŠ” ì‹¤ì œ ì§‘ ìœ„ì¹˜ë¥¼ ëª¨ë¥´ê³ , ì˜¤ì§ ê³„ì‚°ëœ ë²¡í„°ë§Œ ì‚¬ìš©<br>
            â€¢ <strong>ê²°ê³¼:</strong> ëŒ€ë¶€ë¶„ ì§‘ ê·¼ì²˜ì— ë„ì°©í•˜ì§€ë§Œ, ì˜¤ë¥˜ë¡œ ì¸í•´ ì•½ê°„ì˜ í¸ì°¨ ë°œìƒ
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const statusDiv = document.getElementById('status');
        const modeIndicator = document.getElementById('modeIndicator');
        const vectorInfo = document.getElementById('vectorInfo');
        
        // ì‹œë®¬ë ˆì´ì…˜ ìƒíƒœ
        let homePosition = null;
        let foodPosition = null;
        let antPosition = null;
        let searchPath = [];  // íƒìƒ‰ ê²½ë¡œ
        let returnPath = [];  // ê·€í™˜ ê²½ë¡œ
        let pathIntegrationVector = { x: 0, y: 0 };  // ê²½ë¡œ ì ë¶„ ë²¡í„° (ëˆ„ì )
        let isRunning = false;
        let setupMode = 'home';  // 'home', 'food', 'ready'
        let finalPosition = null;  // ìµœì¢… ë„ì°© ì§€ì 
        
        // ì‚¬ë§‰ê°œë¯¸ íŒŒë¼ë¯¸í„° (ì—°êµ¬ ê¸°ë°˜)
        const ANT_SPEED = 2;
        const STEP_LENGTH = 15;  // ê° ìŠ¤í…ì˜ ê¸¸ì´
        const TURN_ANGLE_MAX = 60;  // ìµœëŒ€ íšŒì „ ê°ë„
        const ANT_SIZE = 6;
        const FOOD_SIZE = 8;
        const HOME_SIZE = 12;
        
        // í•­ë²• ì˜¤ë¥˜ íŒŒë¼ë¯¸í„° (MÃ¼ller & Wehner, 1988 ì—°êµ¬ ê¸°ë°˜)
        const DISTANCE_ERROR = 0.05;  // ê±°ë¦¬ ì¸¡ì • ì˜¤ë¥˜ 5%
        const ANGLE_ERROR = 5;  // ë°©í–¥ ì¸¡ì • ì˜¤ë¥˜ Â±5ë„
        
        // ìº”ë²„ìŠ¤ í´ë¦­ ì´ë²¤íŠ¸
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (setupMode === 'home') {
                homePosition = { x, y };
                antPosition = { x, y };
                setupMode = 'food';
                modeIndicator.textContent = 'ğŸ– ì´ì œ ë¨¹ì´ ìœ„ì¹˜ë¥¼ í´ë¦­í•˜ì„¸ìš”';
                draw();
            } else if (setupMode === 'food') {
                foodPosition = { x, y };
                setupMode = 'ready';
                modeIndicator.textContent = 'âœ… ì¤€ë¹„ ì™„ë£Œ! ì‹œë®¬ë ˆì´ì…˜ì„ ì‹œì‘í•˜ì„¸ìš”';
                draw();
            }
        });
        
        // ë²¡í„° ê³„ì‚° í•¨ìˆ˜ë“¤
        function addVector(v1, v2) {
            return { x: v1.x + v2.x, y: v1.y + v2.y };
        }
        
        function subtractVector(v1, v2) {
            return { x: v1.x - v2.x, y: v1.y - v2.y };
        }
        
        function getVectorLength(v) {
            return Math.sqrt(v.x * v.x + v.y * v.y);
        }
        
        function normalizeVector(v) {
            const len = getVectorLength(v);
            if (len === 0) return { x: 0, y: 0 };
            return { x: v.x / len, y: v.y / len };
        }
        
        function degToRad(degrees) {
            return degrees * Math.PI / 180;
        }
        
        function radToDeg(radians) {
            return radians * 180 / Math.PI;
        }
        
        function randomAngle(maxDegrees) {
            return degToRad((Math.random() - 0.5) * 2 * maxDegrees);
        }
        
        function distance(p1, p2) {
            return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
        }
        
        // í•­ë²• ì˜¤ë¥˜ë¥¼ ì ìš©í•œ ë²¡í„° ì¸¡ì •
        function measureVectorWithError(actualVector) {
            // ê±°ë¦¬ ì˜¤ë¥˜ ì ìš©
            const distanceError = 1 + (Math.random() - 0.5) * 2 * DISTANCE_ERROR;
            const length = getVectorLength(actualVector) * distanceError;
            
            // ë°©í–¥ ì˜¤ë¥˜ ì ìš©
            const actualAngle = Math.atan2(actualVector.y, actualVector.x);
            const angleError = degToRad((Math.random() - 0.5) * 2 * ANGLE_ERROR);
            const measuredAngle = actualAngle + angleError;
            
            return {
                x: length * Math.cos(measuredAngle),
                y: length * Math.sin(measuredAngle)
            };
        }
        
        // ê·¸ë¦¬ê¸° í•¨ìˆ˜
        function draw() {
            // ë°°ê²½ (ì‚¬ë§‰)
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#f4e4c1');
            gradient.addColorStop(1, '#e8d4a8');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ì‚¬ë§‰ í…ìŠ¤ì²˜
            ctx.fillStyle = 'rgba(139, 69, 19, 0.1)';
            for (let i = 0; i < 150; i++) {
                const x = (i * 123.456) % canvas.width;
                const y = (i * 789.012) % canvas.height;
                const size = Math.random() * 3;
                ctx.fillRect(x, y, size, size);
            }
            
            // íƒìƒ‰ ê²½ë¡œ ê·¸ë¦¬ê¸°
            if (searchPath.length > 1) {
                ctx.strokeStyle = '#2196F3';
                ctx.lineWidth = 2.5;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                ctx.moveTo(searchPath[0].x, searchPath[0].y);
                for (let i = 1; i < searchPath.length; i++) {
                    ctx.lineTo(searchPath[i].x, searchPath[i].y);
                }
                ctx.stroke();
                
                // ìŠ¤í… ë§ˆì»¤
                ctx.fillStyle = 'rgba(33, 150, 243, 0.6)';
                for (let i = 0; i < searchPath.length; i += 3) {
                    ctx.beginPath();
                    ctx.arc(searchPath[i].x, searchPath[i].y, 2.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // ê·€í™˜ ê²½ë¡œ ê·¸ë¦¬ê¸°
            if (returnPath.length > 1) {
                ctx.strokeStyle = '#FF5722';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                ctx.moveTo(returnPath[0].x, returnPath[0].y);
                for (let i = 1; i < returnPath.length; i++) {
                    ctx.lineTo(returnPath[i].x, returnPath[i].y);
                }
                ctx.stroke();
                
                // ê·€í™˜ ê²½ë¡œì— í™”ì‚´í‘œ
                if (returnPath.length > 10) {
                    for (let i = 15; i < returnPath.length; i += 25) {
                        if (i < returnPath.length - 1) {
                            drawArrow(returnPath[i - 5], returnPath[i], '#FF5722', 12);
                        }
                    }
                }
            }
            
            // ê³„ì‚°ëœ ê·€ì†Œ ë²¡í„° í‘œì‹œ (ë¨¹ì´ ìœ„ì¹˜ì—ì„œ)
            if (foodPosition && pathIntegrationVector.x !== 0 && pathIntegrationVector.y !== 0) {
                const vectorEnd = {
                    x: foodPosition.x - pathIntegrationVector.x,
                    y: foodPosition.y - pathIntegrationVector.y
                };
                
                ctx.strokeStyle = 'rgba(156, 39, 176, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([8, 4]);
                ctx.beginPath();
                ctx.moveTo(foodPosition.x, foodPosition.y);
                ctx.lineTo(vectorEnd.x, vectorEnd.y);
                ctx.stroke();
                ctx.setLineDash([]);
                
                drawArrow(foodPosition, vectorEnd, 'rgba(156, 39, 176, 0.6)', 15);
                
                // ë²¡í„° ì •ë³´ í…ìŠ¤íŠ¸
                ctx.fillStyle = 'rgba(156, 39, 176, 0.8)';
                ctx.font = 'bold 11px Arial';
                ctx.fillText('ê³„ì‚°ëœ ê·€ì†Œ ë²¡í„°', vectorEnd.x + 10, vectorEnd.y);
            }
            
            // ìµœì¢… ë„ì°© ì§€ì  í‘œì‹œ
            if (finalPosition) {
                // ë„ì°© ì§€ì  ì›
                ctx.strokeStyle = '#FF9800';
                ctx.fillStyle = 'rgba(255, 152, 0, 0.3)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(finalPosition.x, finalPosition.y, 15, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // X ë§ˆí¬
                ctx.strokeStyle = '#FF9800';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(finalPosition.x - 8, finalPosition.y - 8);
                ctx.lineTo(finalPosition.x + 8, finalPosition.y + 8);
                ctx.moveTo(finalPosition.x + 8, finalPosition.y - 8);
                ctx.lineTo(finalPosition.x - 8, finalPosition.y + 8);
                ctx.stroke();
                
                // ì‹¤ì œ ì§‘ê¹Œì§€ ê±°ë¦¬ì„ 
                ctx.strokeStyle = 'rgba(244, 67, 54, 0.4)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(finalPosition.x, finalPosition.y);
                ctx.lineTo(homePosition.x, homePosition.y);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // ì˜¤ë¥˜ ê±°ë¦¬ í‘œì‹œ
                const errorDist = distance(finalPosition, homePosition);
                const midX = (finalPosition.x + homePosition.x) / 2;
                const midY = (finalPosition.y + homePosition.y) / 2;
                ctx.fillStyle = '#f44336';
                ctx.font = 'bold 12px Arial';
                ctx.fillText(`ì˜¤ë¥˜: ${errorDist.toFixed(1)}px`, midX + 5, midY - 5);
            }
            
            // ë‘¥ì§€ (ì¶œë°œì )
            if (homePosition) {
                // ê·¸ë¦¼ì
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                ctx.arc(homePosition.x + 2, homePosition.y + 2, HOME_SIZE, 0, Math.PI * 2);
                ctx.fill();
                
                // ë‘¥ì§€
                ctx.fillStyle = '#8B4513';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2.5;
                ctx.beginPath();
                ctx.arc(homePosition.x, homePosition.y, HOME_SIZE, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // ë‘¥ì§€ ì…êµ¬
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(homePosition.x, homePosition.y, HOME_SIZE / 3, 0, Math.PI * 2);
                ctx.fill();
                
                // ë¼ë²¨
                ctx.fillStyle = '#000';
                ctx.font = 'bold 12px Arial';
                ctx.fillText('ğŸ  ë‘¥ì§€', homePosition.x + 15, homePosition.y - 15);
            }
            
            // ë¨¹ì´
            if (foodPosition) {
                // ê·¸ë¦¼ì
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                ctx.arc(foodPosition.x + 2, foodPosition.y + 2, FOOD_SIZE, 0, Math.PI * 2);
                ctx.fill();
                
                // ë¨¹ì´
                ctx.fillStyle = '#4CAF50';
                ctx.strokeStyle = '#2E7D32';
                ctx.lineWidth = 2.5;
                ctx.beginPath();
                ctx.arc(foodPosition.x, foodPosition.y, FOOD_SIZE, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // ë¨¹ì´ ë””í…Œì¼
                ctx.fillStyle = '#81C784';
                ctx.beginPath();
                ctx.arc(foodPosition.x - 2, foodPosition.y - 2, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // ë¼ë²¨
                ctx.fillStyle = '#000';
                ctx.font = 'bold 12px Arial';
                ctx.fillText('ğŸ– ë¨¹ì´', foodPosition.x + 12, foodPosition.y - 12);
            }
            
            // ê°œë¯¸
if (antPosition) {
    // --- ê¸°ë³¸ ì„¤ì • ---
    const x = antPosition.x; // ê°œë¯¸ì˜ ê¸°ì¤€ì  (ê°€ìŠ´ ì¤‘ì•™)
    const y = antPosition.y;
    const size = ANT_SIZE; // ANT_SIZEë¥¼ í‰ë¶€(ê°€ìŠ´)ì˜ ë°˜ì§€ë¦„ìœ¼ë¡œ ì‚¬ìš©

    // ì´ë¯¸ì§€ ê¸°ë°˜ ìƒ‰ìƒ
    const colorHead = '#7b7b7b';       // ë¨¸ë¦¬ (íšŒìƒ‰)
    const colorThoraxFront = '#2d2d2d'; // ì•ê°€ìŠ´ (ê²€ì •)
    const colorThoraxBack = '#5a5a5a';  // ë’·ê°€ìŠ´ (ì–´ë‘ìš´ íšŒìƒ‰)
    const colorGaster = '#5a5a5a';      // ë°° (ì–´ë‘ìš´ íšŒìƒ‰)
    const colorEye = '#000000';         // ëˆˆ (ê²€ì •)
    const colorAntennae = '#000000';    // ë”ë“¬ì´ (ê²€ì •)
    const colorLegFront = '#2d2d2d';    // ì•/ì¤‘ê°„ ë‹¤ë¦¬ (ê²€ì •)
    const colorLegBack = '#5a5a5a';     // ë’·ë‹¤ë¦¬ (ì–´ë‘ìš´ íšŒìƒ‰)
    
    // [ìˆ˜ì •] ì›ë³¸ì˜ ê·¸ë¦¼ì ì œê±° (ì´ë¯¸ì§€ ìŠ¤íƒ€ì¼ì´ ê·¸ë¦¼ìê°€ ì—†ìŒ)
    
    // --- ëª¸ì²´ ê·¸ë¦¬ê¸° (ë ˆì´ì–´ ìˆœì„œ ì¤‘ìš”: ë’¤ -> ì•) ---

    // [ìˆ˜ì •] 1. ë°° (Gaster) - ë’¤ìª½
    ctx.fillStyle = colorGaster;
    ctx.beginPath();
    // ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle)
    // í‰ë¶€(x,y)ì˜ ì˜¤ë¥¸ìª½ ë’¤ì— íƒ€ì›í˜•ìœ¼ë¡œ ê·¸ë¦¬ê¸°
    ctx.ellipse(x + size * 1.9, y + size * 0.3, size * 1.6, size * 1.1, Math.PI * 0.05, 0, Math.PI * 2);
    ctx.fill();
    // ê½ë¬´ë‹ˆì˜ ë¾°ì¡±í•œ ë¶€ë¶„
    ctx.beginPath();
    ctx.moveTo(x + size * 3.4, y + size * 0.6); // ë¾°ì¡±í•œ ë
    ctx.lineTo(x + size * 3.0, y + size * 0.2); // ìœ—ë©´
    ctx.lineTo(x + size * 3.0, y + size * 1.0); // ì•„ë«ë©´
    ctx.fill();


    // [ìˆ˜ì •] 2. ë’·ë‹¤ë¦¬ (ë°°ì™€ í‰ë¶€ ì‚¬ì´)
    ctx.strokeStyle = colorLegBack;
    ctx.lineWidth = size * 0.5; // ë‘êº¼ìš´ ì„ ìœ¼ë¡œ ê°ì§„ ë‹¤ë¦¬ í‘œí˜„
    ctx.lineCap = 'square';   // ì„  ëì„ ë„¤ëª¨ë‚˜ê²Œ
    ctx.lineJoin = 'miter';   // êº¾ì´ëŠ” ë¶€ë¶„ì„ ê°ì§€ê²Œ
    ctx.beginPath();
    ctx.moveTo(x + size * 0.4, y + size * 0.7); // ëª¸í†µ ì—°ê²°
    ctx.lineTo(x + size * 0.8, y + size * 1.8); // ë¬´ë¦
    ctx.lineTo(x + size * 1.5, y + size * 2.2); // ë°œ
    ctx.stroke();

    // [ìˆ˜ì •] 3. í‰ë¶€ (Thorax) - ì¤‘ì•™ ëª¸í†µ (ë°˜ì› 2ê°œë¡œ ë¶„í• )
    const thoraxRadius = size;
    // ë’·ë¶€ë¶„ (ì–´ë‘ìš´ íšŒìƒ‰)
    ctx.fillStyle = colorThoraxBack;
    ctx.beginPath();
    ctx.arc(x, y, thoraxRadius, -Math.PI / 2, Math.PI / 2); // ì˜¤ë¥¸ìª½ ë°˜ì›
    ctx.fill();
    // ì•ë¶€ë¶„ (ê²€ì •)
    ctx.fillStyle = colorThoraxFront;
    ctx.beginPath();
    ctx.arc(x, y, thoraxRadius, Math.PI / 2, -Math.PI / 2); // ì™¼ìª½ ë°˜ì›
    ctx.fill();

    // [ìˆ˜ì •] 4. ì¤‘ê°„ ë‹¤ë¦¬
    ctx.strokeStyle = colorLegFront;
    ctx.lineWidth = size * 0.5;
    ctx.beginPath();
    ctx.moveTo(x, y + size * 0.8); // ëª¸í†µ ì—°ê²° (ì¤‘ì•™ í•˜ë‹¨)
    ctx.lineTo(x - size * 0.5, y + size * 1.6); // ì§€ê·¸(zig)
    ctx.lineTo(x, y + size * 2.4); // ì¬ê·¸(zag)
    ctx.stroke();

    // [ìˆ˜ì •] 5. ì•ë‹¤ë¦¬
    ctx.strokeStyle = colorLegFront;
    ctx.lineWidth = size * 0.5;
    ctx.beginPath();
    ctx.moveTo(x - size * 0.4, y + size * 0.7); // ëª¸í†µ ì—°ê²°
    ctx.lineTo(x - size * 1.0, y + size * 1.5); // ë¬´ë¦
    ctx.lineTo(x - size * 0.8, y + size * 2.4); // ë°œ
    ctx.stroke();
    
    // [ìˆ˜ì •] 6. ë¨¸ë¦¬ (Head) - ë‹¤ê°í˜•ìœ¼ë¡œ ê·¸ë¦¬ê¸°
    ctx.fillStyle = colorHead;
    ctx.beginPath();
    ctx.moveTo(x - size * 0.7, y - size * 0.8); // ë’·ëª© (ìœ„)
    ctx.lineTo(x - size * 0.7, y + size * 0.3); // ë’·ëª© (ì•„ë˜)
    ctx.lineTo(x - size * 2.4, y - size * 0.1); // í„± ë
    ctx.lineTo(x - size * 2.5, y - size * 0.3); // ì½” ë
    ctx.lineTo(x - size * 1.5, y - size * 0.9); // ì´ë§ˆ
    ctx.closePath();
    ctx.fill();

    // [ìˆ˜ì •] 7. ëˆˆ (Eye) - ì‚¬ê°í˜•
    ctx.fillStyle = colorEye;
    ctx.fillRect(x - size * 1.6, y - size * 0.6, size * 0.4, size * 0.4);

    // [ìˆ˜ì •] 8. ë”ë“¬ì´ (Antennae)
    ctx.strokeStyle = colorAntennae;
    ctx.lineWidth = size * 0.3; // ë‹¤ë¦¬ë³´ë‹¤ ì‚´ì§ ê°€ëŠ˜ê²Œ
    ctx.beginPath();
    ctx.moveTo(x - size * 1.8, y - size * 0.8); // ë¨¸ë¦¬ ì—°ê²°
    ctx.lineTo(x - size * 2.2, y - size * 1.6); // ì²« ë²ˆì§¸ ë§ˆë””
    ctx.lineTo(x - size * 1.2, y - size * 1.8); // ë‘ ë²ˆì§¸ ë§ˆë””
    ctx.stroke();

    // --- ì„¤ì • ì´ˆê¸°í™” ---
    // ë‹¤ë¥¸ ê·¸ë¦¼ì— ì˜í–¥ì„ ì£¼ì§€ ì•Šë„ë¡ ì„  ìŠ¤íƒ€ì¼ì„ ë˜ëŒë¦½ë‹ˆë‹¤.
    ctx.lineCap = 'butt';
    ctx.lineJoin = 'round';
    ctx.lineWidth = 1;
}
        }
        
        // í™”ì‚´í‘œ ê·¸ë¦¬ê¸°
        function drawArrow(from, to, color, headLength = 12) {
            const dx = to.x - from.x;
            const dy = to.y - from.y;
            const angle = Math.atan2(dy, dx);
            
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            
            ctx.beginPath();
            ctx.moveTo(to.x, to.y);
            ctx.lineTo(
                to.x - headLength * Math.cos(angle - Math.PI / 7),
                to.y - headLength * Math.sin(angle - Math.PI / 7)
            );
            ctx.moveTo(to.x, to.y);
            ctx.lineTo(
                to.x - headLength * Math.cos(angle + Math.PI / 7),
                to.y - headLength * Math.sin(angle + Math.PI / 7)
            );
            ctx.stroke();
        }
        
        // ë²¡í„° ì •ë³´ ì—…ë°ì´íŠ¸
        function updateVectorInfo() {
            const vecLen = getVectorLength(pathIntegrationVector);
            const vectorAngle = Math.atan2(-pathIntegrationVector.y, -pathIntegrationVector.x);
            const vectorAngleDeg = radToDeg(vectorAngle);
            
            let info = `ğŸ“Š ê²½ë¡œ ì ë¶„ ìƒíƒœ:<br>`;
            info += `â€¢ ëˆ„ì  ë²¡í„°: (${pathIntegrationVector.x.toFixed(2)}, ${pathIntegrationVector.y.toFixed(2)})<br>`;
            info += `â€¢ ê·€ì†Œ ë²¡í„° ê¸¸ì´: ${vecLen.toFixed(2)}px<br>`;
            info += `â€¢ ê·€ì†Œ ë°©í–¥: ${vectorAngleDeg.toFixed(1)}Â°<br>`;
            info += `â€¢ íƒìƒ‰ ìŠ¤í… ìˆ˜: ${searchPath.length}`;
            
            if (finalPosition) {
                const actualDistance = distance(homePosition, foodPosition);
                const errorDistance = distance(finalPosition, homePosition);
                const errorPercent = (errorDistance / actualDistance * 100).toFixed(1);
                info += `<br><br>ğŸ¯ ê·€í™˜ ì™„ë£Œ:<br>`;
                info += `â€¢ ì‹¤ì œ ë‘¥ì§€-ë¨¹ì´ ê±°ë¦¬: ${actualDistance.toFixed(1)}px<br>`;
                info += `â€¢ <span class="error-indicator">ë„ì°© ì§€ì  ì˜¤ë¥˜: ${errorDistance.toFixed(1)}px (${errorPercent}%)</span>`;
            }
            
            vectorInfo.innerHTML = info;
        }
        
        // ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘
        function startSimulation() {
            if (!homePosition || !foodPosition) {
                alert('ì¶œë°œì ê³¼ ë¨¹ì´ ìœ„ì¹˜ë¥¼ ë¨¼ì € ì„¤ì •í•´ì£¼ì„¸ìš”!');
                return;
            }
            
            if (isRunning) {
                return;
            }
            
            isRunning = true;
            antPosition = { ...homePosition };
            searchPath = [{ ...homePosition }];
            returnPath = [];
            pathIntegrationVector = { x: 0, y: 0 };
            finalPosition = null;
            currentAngle = Math.random() * Math.PI * 2;
            
            updateVectorInfo();
            searchForFood();
        }
        
        // ë¨¹ì´ íƒìƒ‰ (ëœë¤ ì›Œí¬)
        let currentAngle = Math.random() * Math.PI * 2;
        
        function searchForFood() {
            if (!isRunning) return;
            
            // ë¨¹ì´ë¥¼ ì°¾ì•˜ëŠ”ì§€ í™•ì¸
            if (distance(antPosition, foodPosition) < FOOD_SIZE + ANT_SIZE) {
                statusDiv.textContent = 'ğŸ‰ ë¨¹ì´ ë°œê²¬! ê²½ë¡œ ì ë¶„ìœ¼ë¡œ ê³„ì‚°ëœ ë°©í–¥ìœ¼ë¡œ ê·€í™˜í•©ë‹ˆë‹¤...';
                statusDiv.style.color = '#4CAF50';
                updateVectorInfo();
                setTimeout(returnHome, 1000);
                return;
            }
            
            // Correlated Random Walk
            currentAngle += randomAngle(TURN_ANGLE_MAX);
            
            // ì‹¤ì œ ì´ë™ ë²¡í„°
            const actualStep = {
                x: Math.cos(currentAngle) * STEP_LENGTH,
                y: Math.sin(currentAngle) * STEP_LENGTH
            };
            
            // ìƒˆë¡œìš´ ìœ„ì¹˜ ê³„ì‚°
            let newPosition = {
                x: antPosition.x + actualStep.x,
                y: antPosition.y + actualStep.y
            };
            
            // ê²½ê³„ ì²´í¬ ë° ë°˜ì‚¬
            if (newPosition.x < ANT_SIZE || newPosition.x > canvas.width - ANT_SIZE) {
                currentAngle = Math.PI - currentAngle;
                actualStep.x = -actualStep.x;
            }
            if (newPosition.y < ANT_SIZE || newPosition.y > canvas.height - ANT_SIZE) {
                currentAngle = -currentAngle;
                actualStep.y = -actualStep.y;
            }
            
            // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
            antPosition.x = Math.max(ANT_SIZE, Math.min(canvas.width - ANT_SIZE, antPosition.x + actualStep.x));
            antPosition.y = Math.max(ANT_SIZE, Math.min(canvas.height - ANT_SIZE, antPosition.y + actualStep.y));
            
            searchPath.push({ ...antPosition });
            
            // â˜… í•µì‹¬: ê²½ë¡œ ì ë¶„ - ì¸¡ì • ì˜¤ë¥˜ê°€ í¬í•¨ëœ ë²¡í„°ë¥¼ ëˆ„ì 
            const measuredStep = measureVectorWithError(actualStep);
            pathIntegrationVector = addVector(pathIntegrationVector, measuredStep);
            
            statusDiv.textContent = `ğŸ” ë¨¹ì´ íƒìƒ‰ ì¤‘... (ìŠ¤í…: ${searchPath.length}, ë²¡í„° ê¸¸ì´: ${getVectorLength(pathIntegrationVector).toFixed(1)}px)`;
            statusDiv.style.color = '#2196F3';
            
            updateVectorInfo();
            draw();
            setTimeout(searchForFood, 50);
        }
        
        // ì§‘ìœ¼ë¡œ ê·€í™˜ (ê²½ë¡œ ì ë¶„ ë²¡í„° ì‚¬ìš©)
        function returnHome() {
            if (!isRunning) return;
            
            if (returnPath.length === 0) {
                returnPath = [{ ...antPosition }];
            }
            
            // â˜… í•µì‹¬: ëˆ„ì ëœ ë²¡í„°ì˜ ë‚¨ì€ ê¸¸ì´
            const remainingVectorLength = getVectorLength(pathIntegrationVector);
            
            // ë²¡í„°ë¥¼ ë‹¤ ì†Œì§„í–ˆìœ¼ë©´ ê·€í™˜ ì™„ë£Œ
            if (remainingVectorLength < ANT_SPEED) {
                isRunning = false;
                finalPosition = { ...antPosition };
                
                const actualError = distance(antPosition, homePosition);
                const totalDistance = distance(homePosition, foodPosition);
                const errorPercent = (actualError / totalDistance * 100).toFixed(1);
                
                statusDiv.innerHTML = `âœ… ê·€í™˜ ì™„ë£Œ!<br>` +
                    `ì‹¤ì œ ì˜¤ë¥˜: ${actualError.toFixed(1)}px (${errorPercent}%) - ` +
                    `ê²½ë¡œ ì ë¶„ì˜ ì •í™•ë„ë¥¼ í™•ì¸í•˜ì„¸ìš”!`;
                statusDiv.style.color = '#4CAF50';
                
                updateVectorInfo();
                draw();
                return;
            }
            
            // â˜… í•µì‹¬: ê³„ì‚°ëœ ë²¡í„°ì˜ ì—­ë°©í–¥ìœ¼ë¡œ ì´ë™ (ì‹¤ì œ ì§‘ ìœ„ì¹˜ë¥¼ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ!)
            const homeDirection = normalizeVector({
                x: -pathIntegrationVector.x,
                y: -pathIntegrationVector.y
            });
            
            // ì´ë™
            const moveStep = {
                x: homeDirection.x * ANT_SPEED,
                y: homeDirection.y * ANT_SPEED
            };
            
            antPosition.x += moveStep.x;
            antPosition.y += moveStep.y;
            returnPath.push({ ...antPosition });
            
            // ë²¡í„°ì—ì„œ ì´ë™í•œ ë§Œí¼ ì°¨ê° (ì•½ê°„ì˜ ì˜¤ë¥˜ í¬í•¨)
            const measuredMove = measureVectorWithError(moveStep);
            pathIntegrationVector.x += measuredMove.x;  // ì—­ë°©í–¥ì´ë¯€ë¡œ ë”í•˜ê¸°
            pathIntegrationVector.y += measuredMove.y;
            
            statusDiv.textContent = `ğŸ  ê·€í™˜ ì¤‘... (ë‚¨ì€ ë²¡í„°: ${remainingVectorLength.toFixed(1)}px)`;
            statusDiv.style.color = '#FF5722';
            
            updateVectorInfo();
            draw();
            setTimeout(returnHome, 30);
        }
        
        // ë¦¬ì…‹
        function resetSimulation() {
            isRunning = false;
            antPosition = homePosition ? { ...homePosition } : null;
            searchPath = [];
            returnPath = [];
            pathIntegrationVector = { x: 0, y: 0 };
            finalPosition = null;
            currentAngle = Math.random() * Math.PI * 2;
            statusDiv.textContent = '';
            vectorInfo.innerHTML = '';
            draw();
        }
        
        // ì „ì²´ ì§€ìš°ê¸°
        function clearCanvas() {
            isRunning = false;
            homePosition = null;
            foodPosition = null;
            antPosition = null;
            searchPath = [];
            returnPath = [];
            pathIntegrationVector = { x: 0, y: 0 };
            finalPosition = null;
            setupMode = 'home';
            statusDiv.textContent = '';
            vectorInfo.innerHTML = '';
            modeIndicator.textContent = 'ğŸ“ ë¨¼ì € ì¶œë°œì (ë‘¥ì§€)ì„ í´ë¦­í•˜ì„¸ìš”';
            draw();
        }
        
        // ì´ˆê¸° ê·¸ë¦¬ê¸°
        draw();
    </script>
</body>
</html>